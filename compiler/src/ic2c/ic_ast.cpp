// ==============================================================================================
// ╦  ┬┌─┐┌─┐┌┐┌┌─┐┌─┐    Yaksha Programming Language
// ║  ││  ├┤ │││└─┐├┤     is Licensed with GPLv3 + exta terms. Please see below.
// ╩═╝┴└─┘└─┘┘└┘└─┘└─┘
// Note: libs - MIT license, runtime/3rd - various
// ==============================================================================================
// GPLv3:
//
// Yaksha - Programming Language.
// Copyright (C) 2020 - 2023 Bhathiya Perera
//
// This program is free software: you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software Foundation,
// either version 3 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with this program.
// If not, see https://www.gnu.org/licenses/.
//
// ==============================================================================================
// Additional Terms:
//
// Please note that any commercial use of the programming language's compiler source code
// (everything except compiler/runtime, compiler/libs and compiler/3rd) require a written agreement
// with author of the language (Bhathiya Perera).
//
// If you are using it for an open source project, please give credits.
// Your own project must use GPLv3 license with these additional terms.
//
// You may use programs written in Yaksha/YakshaLisp for any legal purpose
// (commercial, open-source, closed-source, etc) as long as it agrees
// to the licenses of linked runtime libraries (see compiler/runtime/README.md).
//
// ==============================================================================================
// ic_ast.cpp
// generated by ic_update_ast.py
#include "ic_ast.h"
using namespace yaksha;
// ------- expressions -----
ic_assign_expr::ic_assign_expr(ic_token *name, ic_token *opr, ic_expr *right)
    : name_(name), opr_(opr), right_(right) {}
void ic_assign_expr::accept(ic_expr_visitor *v) {
  v->visit_ic_assign_expr(this);
}
ic_ast_type ic_assign_expr::get_type() { return ic_ast_type::EXPR_ASSIGN; }
ic_expr *ic_ast_pool::ic_c_assign_expr(ic_token *name, ic_token *opr,
                                       ic_expr *right) {
  auto o = new ic_assign_expr(name, opr, right);
  cleanup_expr_.push_back(o);
  return o;
}
// ------- statements -----
ic_pp_block_stmt::ic_pp_block_stmt(std::vector<ic_stmt *> statements)
    : statements_(std::move(statements)) {}
void ic_pp_block_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_block_stmt(this);
}
ic_ast_type ic_pp_block_stmt::get_type() { return ic_ast_type::STMT_PP_BLOCK; }
ic_stmt *ic_ast_pool::ic_c_pp_block_stmt(std::vector<ic_stmt *> statements) {
  auto o = new ic_pp_block_stmt(std::move(statements));
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_code_line_stmt::ic_pp_code_line_stmt(std::vector<ic_token *> token_string,
                                           ic_token *t_newline)
    : token_string_(std::move(token_string)), t_newline_(t_newline) {}
void ic_pp_code_line_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_code_line_stmt(this);
}
ic_ast_type ic_pp_code_line_stmt::get_type() {
  return ic_ast_type::STMT_PP_CODE_LINE;
}
ic_stmt *
ic_ast_pool::ic_c_pp_code_line_stmt(std::vector<ic_token *> token_string,
                                    ic_token *t_newline) {
  auto o = new ic_pp_code_line_stmt(std::move(token_string), t_newline);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_define_function_stmt::ic_pp_define_function_stmt(
    ic_token *t_hash, ic_token *t_define, ic_token *t_identifier,
    ic_token *t_paren_open, std::vector<ic_token *> params,
    ic_token *t_paren_close, std::vector<ic_token *> token_string)
    : t_hash_(t_hash), t_define_(t_define), t_identifier_(t_identifier),
      t_paren_open_(t_paren_open), params_(std::move(params)),
      t_paren_close_(t_paren_close), token_string_(std::move(token_string)) {}
void ic_pp_define_function_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_define_function_stmt(this);
}
ic_ast_type ic_pp_define_function_stmt::get_type() {
  return ic_ast_type::STMT_PP_DEFINE_FUNCTION;
}
ic_stmt *ic_ast_pool::ic_c_pp_define_function_stmt(
    ic_token *t_hash, ic_token *t_define, ic_token *t_identifier,
    ic_token *t_paren_open, std::vector<ic_token *> params,
    ic_token *t_paren_close, std::vector<ic_token *> token_string) {
  auto o = new ic_pp_define_function_stmt(
      t_hash, t_define, t_identifier, t_paren_open, std::move(params),
      t_paren_close, std::move(token_string));
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_define_normal_stmt::ic_pp_define_normal_stmt(
    ic_token *t_hash, ic_token *t_define, ic_token *t_identifier,
    std::vector<ic_token *> token_string)
    : t_hash_(t_hash), t_define_(t_define), t_identifier_(t_identifier),
      token_string_(std::move(token_string)) {}
void ic_pp_define_normal_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_define_normal_stmt(this);
}
ic_ast_type ic_pp_define_normal_stmt::get_type() {
  return ic_ast_type::STMT_PP_DEFINE_NORMAL;
}
ic_stmt *
ic_ast_pool::ic_c_pp_define_normal_stmt(ic_token *t_hash, ic_token *t_define,
                                        ic_token *t_identifier,
                                        std::vector<ic_token *> token_string) {
  auto o = new ic_pp_define_normal_stmt(t_hash, t_define, t_identifier,
                                        std::move(token_string));
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_error_stmt::ic_pp_error_stmt(ic_token *t_hash, ic_token *t_error,
                                   std::vector<ic_token *> token_string)
    : t_hash_(t_hash), t_error_(t_error),
      token_string_(std::move(token_string)) {}
void ic_pp_error_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_error_stmt(this);
}
ic_ast_type ic_pp_error_stmt::get_type() { return ic_ast_type::STMT_PP_ERROR; }
ic_stmt *ic_ast_pool::ic_c_pp_error_stmt(ic_token *t_hash, ic_token *t_error,
                                         std::vector<ic_token *> token_string) {
  auto o = new ic_pp_error_stmt(t_hash, t_error, std::move(token_string));
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_if_stmt::ic_pp_if_stmt(ic_stmt *if_t, std::vector<ic_stmt *> elifs,
                             ic_stmt *else_t, ic_stmt *endif_t)
    : if_t_(if_t), elifs_(std::move(elifs)), else_t_(else_t),
      endif_t_(endif_t) {}
void ic_pp_if_stmt::accept(ic_stmt_visitor *v) { v->visit_ic_pp_if_stmt(this); }
ic_ast_type ic_pp_if_stmt::get_type() { return ic_ast_type::STMT_PP_IF; }
ic_stmt *ic_ast_pool::ic_c_pp_if_stmt(ic_stmt *if_t,
                                      std::vector<ic_stmt *> elifs,
                                      ic_stmt *else_t, ic_stmt *endif_t) {
  auto o = new ic_pp_if_stmt(if_t, std::move(elifs), else_t, endif_t);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_include_stmt::ic_pp_include_stmt(ic_token *t_hash, ic_token *t_include,
                                       ic_token *t_path_spec)
    : t_hash_(t_hash), t_include_(t_include), t_path_spec_(t_path_spec) {}
void ic_pp_include_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_include_stmt(this);
}
ic_ast_type ic_pp_include_stmt::get_type() {
  return ic_ast_type::STMT_PP_INCLUDE;
}
ic_stmt *ic_ast_pool::ic_c_pp_include_stmt(ic_token *t_hash,
                                           ic_token *t_include,
                                           ic_token *t_path_spec) {
  auto o = new ic_pp_include_stmt(t_hash, t_include, t_path_spec);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_line_stmt::ic_pp_line_stmt(ic_token *t_hash, ic_token *t_line,
                                 ic_token *t_line_number, ic_token *t_path_spec)
    : t_hash_(t_hash), t_line_(t_line), t_line_number_(t_line_number),
      t_path_spec_(t_path_spec) {}
void ic_pp_line_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_line_stmt(this);
}
ic_ast_type ic_pp_line_stmt::get_type() { return ic_ast_type::STMT_PP_LINE; }
ic_stmt *ic_ast_pool::ic_c_pp_line_stmt(ic_token *t_hash, ic_token *t_line,
                                        ic_token *t_line_number,
                                        ic_token *t_path_spec) {
  auto o = new ic_pp_line_stmt(t_hash, t_line, t_line_number, t_path_spec);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_pragma_stmt::ic_pp_pragma_stmt(ic_token *t_hash, ic_token *t_pragma,
                                     std::vector<ic_token *> token_string)
    : t_hash_(t_hash), t_pragma_(t_pragma),
      token_string_(std::move(token_string)) {}
void ic_pp_pragma_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_pragma_stmt(this);
}
ic_ast_type ic_pp_pragma_stmt::get_type() {
  return ic_ast_type::STMT_PP_PRAGMA;
}
ic_stmt *
ic_ast_pool::ic_c_pp_pragma_stmt(ic_token *t_hash, ic_token *t_pragma,
                                 std::vector<ic_token *> token_string) {
  auto o = new ic_pp_pragma_stmt(t_hash, t_pragma, std::move(token_string));
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_undef_stmt::ic_pp_undef_stmt(ic_token *t_hash, ic_token *t_undef,
                                   ic_token *t_identifier)
    : t_hash_(t_hash), t_undef_(t_undef), t_identifier_(t_identifier) {}
void ic_pp_undef_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_undef_stmt(this);
}
ic_ast_type ic_pp_undef_stmt::get_type() { return ic_ast_type::STMT_PP_UNDEF; }
ic_stmt *ic_ast_pool::ic_c_pp_undef_stmt(ic_token *t_hash, ic_token *t_undef,
                                         ic_token *t_identifier) {
  auto o = new ic_pp_undef_stmt(t_hash, t_undef, t_identifier);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_warning_stmt::ic_pp_warning_stmt(ic_token *t_hash, ic_token *t_warning,
                                       std::vector<ic_token *> token_string)
    : t_hash_(t_hash), t_warning_(t_warning),
      token_string_(std::move(token_string)) {}
void ic_pp_warning_stmt::accept(ic_stmt_visitor *v) {
  v->visit_ic_pp_warning_stmt(this);
}
ic_ast_type ic_pp_warning_stmt::get_type() {
  return ic_ast_type::STMT_PP_WARNING;
}
ic_stmt *
ic_ast_pool::ic_c_pp_warning_stmt(ic_token *t_hash, ic_token *t_warning,
                                  std::vector<ic_token *> token_string) {
  auto o = new ic_pp_warning_stmt(t_hash, t_warning, std::move(token_string));
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_elif_line_stmt::ic_pp_elif_line_stmt(
    ic_token *t_hash, ic_token *t_elif_t, std::vector<ic_token *> if_expression,
    ic_stmt *block)
    : t_hash_(t_hash), t_elif_t_(t_elif_t),
      if_expression_(std::move(if_expression)), block_(block) {}
ic_ast_type ic_pp_elif_line_stmt::get_type() {
  return ic_ast_type::STMT_PP_ELIF_LINE;
}
void ic_pp_elif_line_stmt::accept(ic_stmt_visitor *v) {}
ic_stmt *
ic_ast_pool::ic_c_pp_elif_line_stmt(ic_token *t_hash, ic_token *t_elif_t,
                                    std::vector<ic_token *> if_expression,
                                    ic_stmt *block) {
  auto o = new ic_pp_elif_line_stmt(t_hash, t_elif_t, std::move(if_expression),
                                    block);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_else_line_stmt::ic_pp_else_line_stmt(ic_token *t_hash, ic_token *t_else_t,
                                           ic_stmt *block)
    : t_hash_(t_hash), t_else_t_(t_else_t), block_(block) {}
ic_ast_type ic_pp_else_line_stmt::get_type() {
  return ic_ast_type::STMT_PP_ELSE_LINE;
}
void ic_pp_else_line_stmt::accept(ic_stmt_visitor *v) {}
ic_stmt *ic_ast_pool::ic_c_pp_else_line_stmt(ic_token *t_hash,
                                             ic_token *t_else_t,
                                             ic_stmt *block) {
  auto o = new ic_pp_else_line_stmt(t_hash, t_else_t, block);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_endif_line_stmt::ic_pp_endif_line_stmt(ic_token *t_hash,
                                             ic_token *t_elif_t)
    : t_hash_(t_hash), t_elif_t_(t_elif_t) {}
ic_ast_type ic_pp_endif_line_stmt::get_type() {
  return ic_ast_type::STMT_PP_ENDIF_LINE;
}
void ic_pp_endif_line_stmt::accept(ic_stmt_visitor *v) {}
ic_stmt *ic_ast_pool::ic_c_pp_endif_line_stmt(ic_token *t_hash,
                                              ic_token *t_elif_t) {
  auto o = new ic_pp_endif_line_stmt(t_hash, t_elif_t);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_if_line_stmt::ic_pp_if_line_stmt(ic_token *t_hash, ic_token *t_if_t,
                                       std::vector<ic_token *> if_expression,
                                       ic_stmt *block)
    : t_hash_(t_hash), t_if_t_(t_if_t),
      if_expression_(std::move(if_expression)), block_(block) {}
ic_ast_type ic_pp_if_line_stmt::get_type() {
  return ic_ast_type::STMT_PP_IF_LINE;
}
void ic_pp_if_line_stmt::accept(ic_stmt_visitor *v) {}
ic_stmt *
ic_ast_pool::ic_c_pp_if_line_stmt(ic_token *t_hash, ic_token *t_if_t,
                                  std::vector<ic_token *> if_expression,
                                  ic_stmt *block) {
  auto o =
      new ic_pp_if_line_stmt(t_hash, t_if_t, std::move(if_expression), block);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_ifdef_line_stmt::ic_pp_ifdef_line_stmt(ic_token *t_hash,
                                             ic_token *t_ifdef_t,
                                             ic_token *t_identifier,
                                             ic_stmt *block)
    : t_hash_(t_hash), t_ifdef_t_(t_ifdef_t), t_identifier_(t_identifier),
      block_(block) {}
ic_ast_type ic_pp_ifdef_line_stmt::get_type() {
  return ic_ast_type::STMT_PP_IFDEF_LINE;
}
void ic_pp_ifdef_line_stmt::accept(ic_stmt_visitor *v) {}
ic_stmt *ic_ast_pool::ic_c_pp_ifdef_line_stmt(ic_token *t_hash,
                                              ic_token *t_ifdef_t,
                                              ic_token *t_identifier,
                                              ic_stmt *block) {
  auto o = new ic_pp_ifdef_line_stmt(t_hash, t_ifdef_t, t_identifier, block);
  cleanup_stmt_.push_back(o);
  return o;
}
ic_pp_ifndef_line_stmt::ic_pp_ifndef_line_stmt(ic_token *t_hash,
                                               ic_token *t_ifndef_t,
                                               ic_token *t_identifier,
                                               ic_stmt *block)
    : t_hash_(t_hash), t_ifndef_t_(t_ifndef_t), t_identifier_(t_identifier),
      block_(block) {}
ic_ast_type ic_pp_ifndef_line_stmt::get_type() {
  return ic_ast_type::STMT_PP_IFNDEF_LINE;
}
void ic_pp_ifndef_line_stmt::accept(ic_stmt_visitor *v) {}
ic_stmt *ic_ast_pool::ic_c_pp_ifndef_line_stmt(ic_token *t_hash,
                                               ic_token *t_ifndef_t,
                                               ic_token *t_identifier,
                                               ic_stmt *block) {
  auto o = new ic_pp_ifndef_line_stmt(t_hash, t_ifndef_t, t_identifier, block);
  cleanup_stmt_.push_back(o);
  return o;
}
// ------- utils ------
ic_ast_pool::~ic_ast_pool() {
  for (auto e : cleanup_expr_) { delete e; }
  for (auto e : cleanup_stmt_) { delete e; }
  cleanup_expr_.clear();
  cleanup_stmt_.clear();
}
ic_ast_pool::ic_ast_pool() {
  cleanup_expr_.reserve(1000);
  cleanup_stmt_.reserve(1000);
}
